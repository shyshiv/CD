1) Tokenizer

#include <stdio.h>
#include <ctype.h>
#include <string.h>

void tokenizer(char* string) {
    for (int i = 0; i < strlen(string); i++) {
        if (isalpha(string[i])) {
            printf("%c is a character.\n", string[i]);
        } else if (string[i] == '+' || string[i] == '-' || string[i] == '*' || string[i] == '/' || string[i] == '%' || string[i] == '^') {
            printf("%c is an operator.\n", string[i]);
        } else if (!isalpha(string[i]) && !isdigit(string[i]) && !isspace(string[i])) {
            printf("%c is a symbol.\n", string[i]);
        } else {
            continue;
        }
    }
}

int main() {
    char s[30];
    printf("Enter the string:");
    scanf("%[^\n]s", s);
    tokenizer(s);
    return 0;
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

2) Symbol Table

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_SYMBOLS 100

const char *keywords[] = {
    "if", "else", "while", "for", "int", "char", "return", /* Add more keywords here */
};
const int NUM_KEYWORDS = sizeof(keywords) / sizeof(keywords[0]);

const char *operators[] = {
    "+", "-", "*", "/", "=", "==", "!=", "<", ">", "<=", ">=",
    /* Add more operators here */
};
const int NUM_OPERATORS = sizeof(operators) / sizeof(operators[0]);

typedef struct {
    char name[20]; // Increase the length to accommodate keywords and operators
    char type[10];
    int index;
    char *address;
    int value;
} SymbolEntry;

SymbolEntry symbolTable[MAX_SYMBOLS];
int symbolCount = 0;
int isSymbolExists(const char *name) {
    int i;
    for (i = 0; i < symbolCount; i++) {
        if (strcmp(symbolTable[i].name, name) == 0) {
            return 1;
        }
    }
    return 0; 
}

int isOperator(const char *symbol) {
    for (int i = 0; i < NUM_OPERATORS; i++) {
        if (strcmp(symbol, operators[i]) == 0) {
            return 1;
        }
    }
    return 0;
}

int isKeyword(const char *symbol) {
    for (int i = 0; i < NUM_KEYWORDS; i++) {
        if (strcmp(symbol, keywords[i]) == 0) {
            return 1;
        }
    }
    return 0;
}

const char *getTokenType(const char *token) {
    if (strlen(token) == 1) {
        if (isalpha(token[0])) {
            return "Character";
        } else if (isdigit(token[0])) {
            return "Digit";
        } else if (isspace(token[0])) {
            return "Space";
        }
    }
    return "Symbol";
}

void insertSymbol(const char *name, char *address, int value) {
    if (symbolCount < MAX_SYMBOLS) {
        if (!isSymbolExists(name)) {
            int isKeyword = 0;
            for (int i = 0; i < NUM_KEYWORDS; i++) {
                if (strcmp(name, keywords[i]) == 0) {
                    isKeyword = 1;
                    break;
                }
            }

            if (isKeyword) {
                strcpy(symbolTable[symbolCount].type, "Keyword");
                symbolTable[symbolCount].value = -1;  // Set a default value for keywords
            } else {
                strcpy(symbolTable[symbolCount].type, getTokenType(name));
                symbolTable[symbolCount].value = value;
            }

            strcpy(symbolTable[symbolCount].name, name);
            symbolTable[symbolCount].index = symbolCount;
            symbolTable[symbolCount].address = address;
            symbolCount++;
        } else {
            printf("Symbol %s already exists in the table.\n", name);
        }
    } else {
        printf("Symbol table is full!\n");
    }
}



void displaySymbolTable() {
    printf("Symbol Table\n");
    printf("+--------------+-----------+----------+-------------------+----------+\n");
    printf("|    Label     |   Type    |  Index   |      Address      |   Value  |\n");
    printf("+--------------+-----------+----------+-------------------+----------+\n");
    int i;
    for (i = 0; i < symbolCount; i++) {
        printf("| %-12s | %-9s | %-8d | %-17p | %-8d |\n",
               symbolTable[i].name, symbolTable[i].type, symbolTable[i].index,
               (void *)symbolTable[i].address, symbolTable[i].value);
        printf("+--------------+-----------+----------+-------------------+----------+\n");
    }
}



int findSymbolIndex(const char *name) {
    int i;
    for (i = 0; i < symbolCount; i++) {
        if (strcmp(symbolTable[i].name, name) == 0) {
            return i;
        }
    }
    return -1; 
}

void displaySymbolInfo(const char *name) {
    int symbolIndex = findSymbolIndex(name);
    if (symbolIndex != -1) {
        printf("Symbol Information:\n");
        printf("Name: %s\n", symbolTable[symbolIndex].name);
        printf("Type: %s\n", symbolTable[symbolIndex].type);
        printf("Index: %d\n", symbolTable[symbolIndex].index);
        printf("Address: %p\n", (void *)symbolTable[symbolIndex].address);
        if (strcmp(symbolTable[symbolIndex].type, "Keyword") != 0) {
            printf("Value: %d\n", symbolTable[symbolIndex].value);
        }
    } else {
        printf("Symbol %s not found!\n", name);
    }
}


int main() {
    int address = 0;
    int choice;
    char input[100];

    while (1) {
        printf("\nSymbol Table Menu:\n");
        printf("1) Display Symbol Table\n");
        printf("2) Add Symbols\n");
        printf("3) Modify Symbol Value\n");
        printf("4) Display Symbol details\n");
        printf("5) Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                displaySymbolTable();
                break;
            case 2:
                printf("Enter a string: ");
                scanf("%s", input);
                int i;
                for (i = 0; input[i] != '\0'; i++) {
                    char symbol[20]; // Increase the length to accommodate keywords and operators
                    symbol[0] = input[i];
                    symbol[1] = '\0';

                    if ((input[i] == '=' && input[i + 1] == '=') || (input[i] == '!' && input[i + 1] == '=')) {
                        symbol[1] = input[i + 1];
                        symbol[2] = '\0';
                        i++; // Skip the second '='
                    } else if (input[i] == '=' && input[i + 1] != '=') {
                        symbol[1] = '\0';
                    } else if (isOperator(symbol)) {
                        insertSymbol(symbol, symbolTable[symbolCount].name, 0);
                        address++;
                    } else if (isalpha(input[i])) {
                        // Handle identifiers and keywords
                        int j = i;
                        int len = 0;
                        while (isalnum(input[j])) {
                            len++;
                            j++;
                        }
                        strncpy(symbol, &input[i], len);
                        symbol[len] = '\0';
                        i = j - 1;

                        if (isKeyword(symbol)) {
                            insertSymbol(symbol, symbolTable[symbolCount].name, 0);
                            address++;
                        } else {
                            insertSymbol(symbol, symbolTable[symbolCount].name, 0);
                            address++;
                        }
                    } else {
                        insertSymbol(symbol, symbolTable[symbolCount].name, 0);
                    address++;
                    }
                }
                break;
            case 3:
                printf("Enter symbol name to modify value: ");
                char symbolName[20]; // Increase the length to accommodate keywords and operators
                scanf("%s", symbolName);
                int symbolIndex = findSymbolIndex(symbolName);
                if (symbolIndex != -1) {
                    if (strcmp(symbolTable[symbolIndex].type, "Keyword") != 0) {
                        int newValue;
                        printf("Enter new value: ");
                        scanf("%d", &newValue);
                        symbolTable[symbolIndex].value = newValue;
                        printf("Value of symbol %s modified.\n", symbolName);
                    } else {
                        printf("Keywords cannot be assigned values.\n");
                    }
                } else {
                    printf("Symbol %s not found!\n", symbolName);
                }
                break;
            case 4:
                printf("Enter symbol name to find information: ");
                char findSymbolName[20]; // Increase the length to accommodate keywords and operators
                scanf("%s", findSymbolName);
                displaySymbolInfo(findSymbolName);
                break;
            case 5:
                printf("Exiting.\n");
                exit(0);
            default:
                printf("Invalid choice. Try again.\n");
        }
    }
    return 0;
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

3) NFA to DFA -> Minimization



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

4) Lexical Analyzer in lex

%{
#include <stdio.h>
%}

%%
[0-9]+[.][0-9]+   { printf("\n%s is a floating-point number\n", yytext); }
[0-9]+            { printf("\n%s is an integer number\n", yytext); }

int|float|char|double|void  { printf("\n%s is a datatype\n", yytext); }

if|else|while|for|return   { printf("\n%s is a keyword\n", yytext); }

[()]   { printf("\n%s is a function\n", yytext); }
[a-zA-Z_][a-zA-Z0-9_]*   { printf("\n%s is an identifier\n", yytext); }

[+=*/-]   { printf("\n%s is an operator\n", yytext); }
[><=]=   { printf("\n%s is a relational operator\n", yytext); }

[@$^&?`~.]   { printf("\n%s is a Symbol\n", yytext); }
;   { printf("\n%s is a delimiter\n", yytext); }
,   { printf("\n%s is a separator\n", yytext); }
[#][a-zA-Z.]+   { printf("\n%s is a preprocessor\n", yytext); }
.   { printf("\n%s is an unrecognized character\n", yytext); }
%%

int yywrap(void)
{
    return 1;
}

int main()
{
    printf("Enter your code (press Ctrl+D to end input):\n");
    yylex();
    return 0;
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

5) Calculator, AST Using Lex

Calculator

LEX PART:

%{

#include<stdio.h>

#include "y.tab.h"

extern int yylval;

%}


%%

[0-9]+ {

          yylval=atoi(yytext);

          return NUMBER;

       }

[\t] ;

[\n] return 0;

. return yytext[0];

%%

int yywrap()

{

return 1;

}

YACC PART:

%{
    #include<stdio.h>

    int flag=0;

%}

%token NUMBER

%left '+' '-'

%left '*' '/' '%'

%left '(' ')'

%%

ArithmeticExpression: E{

         printf("\nResult=%d\n",$$);

         return 0;

        };

E:E'+'E {$$=$1+$3;}

 |E'-'E {$$=$1-$3;}

 |E'*'E {$$=$1*$3;}

 |E'/'E {$$=$1/$3;}

 |E'%'E {$$=$1%$3;}

 |'('E')' {$$=$2;}

 | NUMBER {$$=$1;}

;

%%



void main()

{

   printf("\nEnter Any Arithmetic Expression which can have operations Addition, Subtraction, Multiplication, Divison, Modulus and Round brackets:\n");

   yyparse();

  if(flag==0)

   printf("\nEntered arithmetic expression is Valid\n\n");

}

void yyerror()

{

   printf("\nEntered arithmetic expression is Invalid\n\n");

   flag=1;

}

BNF
//Convert the BNF rules into YACC form and

//write code to generate Abstract Syntax Tree



LEX PART:



%{

#include"y.tab.h"

#include<stdio.h>

#include<string.h>

int LineNo=1;

%}

identifier [a-zA-Z][_a-zA-Z0-9]*

number [0-9]+|([0-9]*\.[0-9]+)

%%

main\(\) return MAIN;

if return IF;

else return ELSE;

while return WHILE;

int |

char |

float return TYPE;

{identifier} {strcpy(yylval.var,yytext);

return VAR;}

{number} {strcpy(yylval.var,yytext);

return NUM;}

\< |

\> |

\>= |

\<= |

== {strcpy(yylval.var,yytext);

return RELOP;}

[ \t] ;

\n LineNo++;

. return yytext[0];

%%



YACC PART:



%{

#include<string.h>

#include<stdio.h>

struct quad

{

char op[5];

char arg1[10];

char arg2[10];

char result[10];

}QUAD[30];

struct stack

{





int items[100];

int top;

}stk;

int Index=0,tIndex=0,StNo,Ind,tInd;

extern int LineNo;

%}

%union

{

char var[10];

}

%token <var> NUM VAR RELOP

%token MAIN IF ELSE WHILE TYPE

%type <var> EXPR ASSIGNMENT CONDITION IFST ELSEST WHILELOOP

%left '-' '+'

%left '*' '/'

%%

PROGRAM : MAIN BLOCK

;

BLOCK: '{' CODE '}'

;

CODE: BLOCK

| STATEMENT CODE

| STATEMENT

;

STATEMENT: DESCT ';'

| ASSIGNMENT ';'

| CONDST

| WHILEST

;

DESCT: TYPE VARLIST

;

VARLIST: VAR ',' VARLIST

| VAR

;

ASSIGNMENT: VAR '=' EXPR{

strcpy(QUAD[Index].op,"=");

strcpy(QUAD[Index].arg1,$3);

strcpy(QUAD[Index].arg2,"");

strcpy(QUAD[Index].result,$1);

strcpy($$,QUAD[Index++].result);

}

;

EXPR: EXPR '+' EXPR {AddQuadruple("+",$1,$3,$$);}

| EXPR '-' EXPR {AddQuadruple("-",$1,$3,$$);}

| EXPR '*' EXPR {AddQuadruple("*",$1,$3,$$);}

| EXPR '/' EXPR {AddQuadruple("/",$1,$3,$$);}

| '-' EXPR {AddQuadruple("UMIN",$2,"",$$);}

| '(' EXPR ')' {strcpy($$,$2);}

| VAR

| NUM





;

CONDST: IFST{

Ind=pop();

sprintf(QUAD[Ind].result,"%d",Index);

Ind=pop();

sprintf(QUAD[Ind].result,"%d",Index);

}

| IFST ELSEST

;

IFST: IF '(' CONDITION ')' {

strcpy(QUAD[Index].op,"==");

strcpy(QUAD[Index].arg1,$3);

strcpy(QUAD[Index].arg2,"FALSE");

strcpy(QUAD[Index].result,"-1");

push(Index);

Index++;

}

BLOCK { strcpy(QUAD[Index].op,"GOTO"); strcpy(QUAD[Index].arg1,""); 

strcpy(QUAD[Index].arg2,"");

strcpy(QUAD[Index].result,"-1");

push(Index);

Index++;

};

ELSEST: ELSE{

tInd=pop();

Ind=pop();

push(tInd);

sprintf(QUAD[Ind].result,"%d",Index);

}

BLOCK{

Ind=pop();

sprintf(QUAD[Ind].result,"%d",Index);

};

CONDITION: VAR RELOP VAR {AddQuadruple($2,$1,$3,$$);

StNo=Index-1;

}

| VAR

| NUM

;

WHILEST: WHILELOOP{

Ind=pop();

sprintf(QUAD[Ind].result,"%d",StNo);

Ind=pop();

sprintf(QUAD[Ind].result,"%d",Index);

}

;

WHILELOOP: WHILE'('CONDITION ')' {

strcpy(QUAD[Index].op,"==");

strcpy(QUAD[Index].arg1,$3);

strcpy(QUAD[Index].arg2,"FALSE");





strcpy(QUAD[Index].result,"-1");

push(Index);

Index++;

}

BLOCK {

strcpy(QUAD[Index].op,"GOTO");

strcpy(QUAD[Index].arg1,"");

strcpy(QUAD[Index].arg2,"");

strcpy(QUAD[Index].result,"-1");

push(Index);

Index++;

}

;

%%

extern FILE *yyin;

int main(int argc,char *argv[])

{

FILE *fp;

int i;

if(argc>1)

{

fp=fopen(argv[1],"r");

if(!fp)

{

printf("\n File not found");

exit(0);

}

yyin=fp;

}

yyparse();

printf("\n\n\t\t ----------------------------""\n\t\t Pos Operator \tArg1 \tArg2 \tResult" "\n\t\t--------------------");

for(i=0;i<Index;i++)

{

printf("\n\t\t %d\t %s\t %s\t %s\t%s",i,QUAD[i].op,QUAD[i].arg1,QUAD[i].arg2,QUAD[i].result);

}

printf("\n\t\t -----------------------");

printf("\n\n"); return 0; }

void push(int data)

{ stk.top++;

if(stk.top==100)

{

printf("\n Stack overflow\n");

exit(0);

}

stk.items[stk.top]=data;

}

int pop()

{

int data;





if(stk.top==-1)

{

printf("\n Stack underflow\n");

exit(0);

}

data=stk.items[stk.top--];

return data;

}

void AddQuadruple(char op[5],char arg1[10],char arg2[10],char result[10])

{

strcpy(QUAD[Index].op,op);

strcpy(QUAD[Index].arg1,arg1);

strcpy(QUAD[Index].arg2,arg2);

sprintf(QUAD[Index].result,"t%d",tIndex++);

strcpy(result,QUAD[Index++].result);

}

yyerror()

{

printf("\n Error on line no:%d",LineNo);

}






INPUT:



main()

{

int a,b,c;

if(a<b)

{

a=a+b;

}

while(a<b)

{

a=a+b;

}

if(a<=b)

{

c=a-b;

}

else

{

c=a+b;

}

}


https://cs6612compilerlab.blogspot.com/2018/04/implementation-of-calculator-using-lex.html
https://cs6612compilerlab.blogspot.com/2018/04/bnf-rules-into-yacc-form-and-write-code.html

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

6) First and Follow


void calculateFirst(char nonTerminal, const unordered_map<char, vector<vector<char>>>& grammar);

void calculateFollow(char nonTerminal, const unordered_map<char, vector<vector<char>>>& grammar) {
    if (followSets.find(nonTerminal) == followSets.end()) { 
        followSets[nonTerminal]; 
    }

    if (nonTerminal == 'S') {
        followSets[nonTerminal].insert('$');
    }

    for (const auto& entry : grammar) {
        char nonTerm = entry.first;
        const vector<vector<char>>& productions = entry.second;

        for (const auto& production : productions) {
            auto it = find(production.begin(), production.end(), nonTerminal);
            if (it != production.end()) {

                size_t index = distance(production.begin(), it) + 1;
                while (index < production.size()) {
                    calculateFirst(production[index], grammar);
                    followSets[nonTerminal].insert(firstSets[production[index]].begin(), firstSets[production[index]].end());

                    if (firstSets[production[index]].find(' ') == firstSets[production[index]].end()) {
                        break;
                    }

                    index++;
                }

                if (index == production.size() || firstSets[production[index - 1]].find(' ') != firstSets[production[index - 1]].end()) {
                    calculateFollow(nonTerm, grammar);
                    followSets[nonTerminal].insert(followSets[nonTerm].begin(), followSets[nonTerm].end());
                }
            }
        }
    }
}

void calculateFirst(char nonTerminal, const unordered_map<char, vector<vector<char>>>& grammar) {
    if (isTerminal(nonTerminal)) {
        firstSets[nonTerminal].insert(nonTerminal);
        return;
    }

    if (firstSets.find(nonTerminal) != firstSets.end()) {
        return;
    }

    for (const auto& production : grammar.at(nonTerminal)) {
        for (char symbol : production) {
            calculateFirst(symbol, grammar);
            firstSets[nonTerminal].insert(firstSets[symbol].begin(), firstSets[symbol].end());

            if (firstSets[symbol].find(' ') == firstSets[symbol].end()) {
                break;
            }
        }
    }

    firstSets[nonTerminal].erase(' ');
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

7) Predictive Parser

#include<stdio.h>
#include<ctype.h>
#include<string.h>
void followfirst(char , int , int);
void findfirst(char , int , int);
void follow(char c);
int count,n=0;
char calc_first[10][100];
char calc_follow[10][100];
int m=0;
char production[10][10], first[10];
char f[10];
int k;
char ck;
int e;

int main(int argc,char **argv)
{
        int jm=0;
        int km=0;
        int i,choice;
        char c,ch;
        printf("How many productions ? :");
        scanf("%d",&count);
        printf("\nEnter %d productions in form A=B where A and B are grammar symbols :\n\n",count);
        for(i=0;i<count;i++)
        {
                scanf("%s%c",production[i],&ch);
        }
        int kay;
        char done[count];
        int ptr = -1;
        for(k=0;k<count;k++){
                for(kay=0;kay<100;kay++){
                        calc_first[k][kay] = '!';
                }
        }
        int point1 = 0,point2,xxx;
        for(k=0;k<count;k++)
        {
                c=production[k][0];
                point2 = 0;
                xxx = 0;
                for(kay = 0; kay <= ptr; kay++)
                        if(c == done[kay])
                                xxx = 1;
                if (xxx == 1)
                        continue;
                findfirst(c,0,0);
                ptr+=1;
                done[ptr] = c;
                printf("\n First(%c)= { ",c);
                calc_first[point1][point2++] = c;
                for(i=0+jm;i<n;i++){
                        int lark = 0,chk = 0;
                        for(lark=0;lark<point2;lark++){
                                if (first[i] == calc_first[point1][lark]){
                                        chk = 1;
                                        break;
                                }
                        }
                        if(chk == 0){
                                printf("%c, ",first[i]);
                                calc_first[point1][point2++] = first[i];
                        }
                }
                printf("}\n");
                jm=n;
                point1++;
        }
        printf("\n");
        printf("-----------------------------------------------\n\n");
        char donee[count];
        ptr = -1;
        for(k=0;k<count;k++){
                for(kay=0;kay<100;kay++){
                        calc_follow[k][kay] = '!';
                }
        }
        point1 = 0;
        int land = 0;
        for(e=0;e<count;e++)
        {
                ck=production[e][0];
                point2 = 0;
                xxx = 0;
                for(kay = 0; kay <= ptr; kay++)
                        if(ck == donee[kay])
                                xxx = 1;
                if (xxx == 1)
                        continue;
                land += 1;
                follow(ck);
                ptr+=1;
                donee[ptr] = ck;
                printf(" Follow(%c) = { ",ck);
                calc_follow[point1][point2++] = ck;
                for(i=0+km;i<m;i++){
                        int lark = 0,chk = 0;
                        for(lark=0;lark<point2;lark++){
                                if (f[i] == calc_follow[point1][lark]){
                                        chk = 1;
                                        break;
                                }
                        }
                        if(chk == 0){
                                printf("%c, ",f[i]);
                                calc_follow[point1][point2++] = f[i];
                        }
                }
                printf(" }\n\n");
                km=m;
                point1++;
        }
        char ter[10];
        for(k=0;k<10;k++){
                ter[k] = '!';
        }
        int ap,vp,sid = 0;
        for(k=0;k<count;k++){
                for(kay=0;kay<count;kay++){
                        if(!isupper(production[k][kay]) && production[k][kay]!= '#' && production[k][kay] != '=' && production[k][kay] != '\0'){
                                vp = 0;
                                for(ap = 0;ap < sid; ap++){
                                        if(production[k][kay] == ter[ap]){
                                                vp = 1;
                                                break;
                                        }
                                }
                                if(vp == 0){
                                        ter[sid] = production[k][kay];
                                        sid ++;
                                }
                        }
                }
        }
        ter[sid] = '$';
        sid++;
        printf("\n\t\t\t\t\t\t\t The LL(1) Parsing Table for the above grammer :-");
        printf("\n\t\t\t\t\t\t\t^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n");
        printf("\n\t\t\t=====================================================================================================================\n");
        printf("\t\t\t\t|\t");
        for(ap = 0;ap < sid; ap++){
                printf("%c\t\t",ter[ap]);
        }
        printf("\n\t\t\t=====================================================================================================================\n");
        char first_prod[count][sid];
        for(ap=0;ap<count;ap++){
                int destiny = 0;
                k = 2;
                int ct = 0;
                char tem[100];
                while(production[ap][k] != '\0'){
                        if(!isupper(production[ap][k])){
                                tem[ct++] = production[ap][k];
                                tem[ct++] = '_';
                                tem[ct++] = '\0';
                                k++;
                                break;
                        }
                        else{
                                int zap=0;
                                int tuna = 0;
                                for(zap=0;zap<count;zap++){
                                        if(calc_first[zap][0] == production[ap][k]){
                                                for(tuna=1;tuna<100;tuna++){
                                                        if(calc_first[zap][tuna] != '!'){
                                                                tem[ct++] = calc_first[zap][tuna];
                                                        }
                                                        else
                                                                break;
                                                }
                                        break;
                                        }
                                }
                                tem[ct++] = '_';
                        }
                        k++;
                }
                int zap = 0,tuna;
                for(tuna = 0;tuna<ct;tuna++){
                        if(tem[tuna] == '#'){
                                zap = 1;
                        }
                        else if(tem[tuna] == '_'){
                                if(zap == 1){
                                        zap = 0;
                                }
                                else
                                        break;
                        }
                        else{
                                first_prod[ap][destiny++] = tem[tuna];
                        }
                }
        }
        char table[land][sid+1];
        ptr = -1;
        for(ap = 0; ap < land ; ap++){
                for(kay = 0; kay < (sid + 1) ; kay++){
                        table[ap][kay] = '!';
                }
        }
        for(ap = 0; ap < count ; ap++){
                ck = production[ap][0];
                xxx = 0;
                for(kay = 0; kay <= ptr; kay++)
                        if(ck == table[kay][0])
                                xxx = 1;
                if (xxx == 1)
                        continue;
                else{
                        ptr = ptr + 1;
                        table[ptr][0] = ck;
                }
        }
        for(ap = 0; ap < count ; ap++){
                int tuna = 0;
                while(first_prod[ap][tuna] != '\0'){
                        int to,ni=0;
                        for(to=0;to<sid;to++){
                                if(first_prod[ap][tuna] == ter[to]){
                                        ni = 1;
                                }
                        }
                        if(ni == 1){
                                char xz = production[ap][0];
                                int cz=0;
                                while(table[cz][0] != xz){
                                        cz = cz + 1;
                                }
                                int vz=0;
                                while(ter[vz] != first_prod[ap][tuna]){
                                        vz = vz + 1;
                                }
                                table[cz][vz+1] = (char)(ap + 65);
                        }
                        tuna++;
                }
        }
        for(k=0;k<sid;k++){
                for(kay=0;kay<100;kay++){
                        if(calc_first[k][kay] == '!'){
                                break;
                        }
                        else if(calc_first[k][kay] == '#'){
                                int fz = 1;
                                while(calc_follow[k][fz] != '!'){
                                        char xz = production[k][0];
                                        int cz=0;
                                        while(table[cz][0] != xz){
                                                cz = cz + 1;
                                        }
                                        int vz=0;
                                        while(ter[vz] != calc_follow[k][fz]){
                                                vz = vz + 1;
                                        }
                                        table[k][vz+1] = '#';
                                        fz++;
                                }
                                break;
                        }
                }
        }
        for(ap = 0; ap < land ; ap++){
                printf("\t\t\t   %c\t|\t",table[ap][0]);
                for(kay = 1; kay < (sid + 1) ; kay++){
                        if(table[ap][kay] == '!')
                                printf("\t\t");
                        else if(table[ap][kay] == '#')
                                printf("%c=#\t\t",table[ap][0]);
                        else{
                                int mum = (int)(table[ap][kay]);
                                mum -= 65;
                                printf("%s\t\t",production[mum]);
                        }
                }
                printf("\n");
                printf("\t\t\t---------------------------------------------------------------------------------------------------------------------");
                printf("\n");
        }
        int j;
        printf("\n\nPlease enter the desired INPUT STRING = ");
        char input[100];
        scanf("%s%c",input,&ch);
        printf("\n\t\t\t\t\t===========================================================================\n");
        printf("\t\t\t\t\t\tStack\t\t\tInput\t\t\tAction");
        printf("\n\t\t\t\t\t===========================================================================\n");
        int i_ptr = 0,s_ptr = 1;
        char stack[100];
        stack[0] = '$';
        stack[1] = table[0][0];
        while(s_ptr != -1){
                printf("\t\t\t\t\t\t");
                int vamp = 0;
                for(vamp=0;vamp<=s_ptr;vamp++){
                        printf("%c",stack[vamp]);
                }
                printf("\t\t\t");
                vamp = i_ptr;
                while(input[vamp] != '\0'){
                        printf("%c",input[vamp]);
                        vamp++;
                }
                printf("\t\t\t");
                char her = input[i_ptr];
                char him = stack[s_ptr];
                s_ptr--;
                if(!isupper(him)){
                        if(her == him){
                                i_ptr++;
                                printf("POP ACTION\n");
                        }
                        else{
                                printf("\nString Not Accepted by LL(1) Parser !!\n");
                                exit(0);
                        }
                }
                else{
                        for(i=0;i<sid;i++){
                                if(ter[i] == her)
                                        break;
                        }
                        char produ[100];
                        for(j=0;j<land;j++){
                                if(him == table[j][0]){
                                        if (table[j][i+1] == '#'){
                                                printf("%c=#\n",table[j][0]);
                                                produ[0] = '#';
                                                produ[1] = '\0';
                                        }
                                        else if(table[j][i+1] != '!'){
                                                int mum = (int)(table[j][i+1]);
                                                mum -= 65;
                                                strcpy(produ,production[mum]);
                                                printf("%s\n",produ);
                                        }
                                        else{
                                                printf("\nString Not Accepted by LL(1) Parser !!\n");
                                                exit(0);
                                        }
                                }
                        }
                        int le = strlen(produ);
                        le = le - 1;
                        if(le == 0){
                                continue;
                        }
                        for(j=le;j>=2;j--){
                                s_ptr++;
                                stack[s_ptr] = produ[j];
                        }
                }
        }
        printf("\n\t\t\t=======================================================================================================================\n");
        if (input[i_ptr] == '\0'){
                printf("\t\t\t\t\t\t\t\tYOUR STRING HAS BEEN ACCEPTED !!\n");
        }
        else
                printf("\n\t\t\t\t\t\t\t\tYOUR STRING HAS BEEN REJECTED !!\n");
        printf("\t\t\t=======================================================================================================================\n");
}

void follow(char c)
{
        int i ,j;
        if(production[0][0]==c){
                f[m++]='$';
        }
        for(i=0;i<10;i++)
        {
                for(j=2;j<10;j++)
                {
                        if(production[i][j]==c)
                        {
                        if(production[i][j+1]!='\0'){
                                        followfirst(production[i][j+1],i,(j+2));
                                }
                        if(production[i][j+1]=='\0'&&c!=production[i][0]){
                                follow(production[i][0]);
                                }
                        }
                }
        }
}

void findfirst(char c ,int q1 , int q2)
{
        int j;
        if(!(isupper(c))){
                first[n++]=c;
        }
        for(j=0;j<count;j++)
        {
                if(production[j][0]==c)
                {
                        if(production[j][2]=='#'){
                                if(production[q1][q2] == '\0')
                                        first[n++]='#';
                                else if(production[q1][q2] != '\0' && (q1 != 0 || q2 != 0))
                                {
                                        findfirst(production[q1][q2], q1, (q2+1));
                                }
                                else
                                        first[n++]='#';
                        }
                        else if(!isupper(production[j][2])){
                                first[n++]=production[j][2];
                        }
                        else {
                                findfirst(production[j][2], j, 3);
                        }
                }
        }
}

void followfirst(char c, int c1 , int c2)
{
    int k;
    if(!(isupper(c)))
                f[m++]=c;
        else{
                int i=0,j=1;
                for(i=0;i<count;i++)
                {
                        if(calc_first[i][0] == c)
                                break;
                }
                while(calc_first[i][j] != '!')
                {
                        if(calc_first[i][j] != '#'){
                                f[m++] = calc_first[i][j];
                        }
                        else{
                                if(production[c1][c2] == '\0'){
                                        follow(production[c1][0]); }
                                else{
                                        followfirst(production[c1][c2],c1,c2+1);
                                }
                        }
                        j++;
                }
        }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

8) SLR Parser

#include<bits/stdc++.h>
#define error(x) cerr<<#x<<" = "<<x<<'\n'
using namespace std;

set<char> ss;
map<char,vector<vector<char>>> mp;
bool dfs(char i, char org, char last, map<char,vector<vector<char>>> &mp){
    bool rtake = false;
    for(auto r : mp[i]){
        bool take = true;
        for(auto s : r){
            if(s == i) break;
            if(!take) break;
            if(!(s>='A'&&s<='Z')&&s!='e'){
                ss.insert(s);
                break;
            }
            else if(s == 'e'){
                if(org == i||i == last)
                ss.insert(s);
                rtake = true;
                break;
            }
            else{
                take = dfs(s,org,r[r.size()-1],mp);
                rtake |= take;
            }}}
    return rtake;
}

map<int,map<char,set<pair<deque<char>,deque<char>>>>> f;
map<int,vector<pair<int,char>>> g;

int num = -1;
void dfs2(char c, char way, int last, pair<deque<char>,deque<char>> curr){
    map<char,set<pair<deque<char>,deque<char>>>> mp2;
    int rep = -2;
    if(last != -1){
        for(auto q : g[last]){
            if(q.second == way){
                rep = q.first;
                mp2 = f[q.first];
            }}}
    mp2[c].insert(curr);
    int count = 10;
    while(count--){
        for(auto q : mp2){
            for(auto r : q.second){
                if(!r.second.empty()){
                    if(r.second.front()>='A'&&r.second.front()<='Z'){
                        for(auto s : mp[r.second.front()]){
                            deque<char> st,emp;
                            for(auto t : s) st.push_back(t);
                            mp2[r.second.front()].insert({emp,st});
                        }}}}}}
    for(auto q : f){
        if(q.second == mp2){
            g[last].push_back({q.first,way});
            return; }}
    if(rep == -2){
        f[++num] = mp2;
        if(last != -1)
        g[last].push_back({num,way});
    }
    else{
        f[rep] = mp2;
    }
    int cc = num;
    for(auto q : mp2){
        for(auto r : q.second){
            if(!r.second.empty()){
                r.first.push_back(r.second.front());
                r.second.pop_front();
                dfs2(q.first,r.first.back(),cc,r);
            }}}}

int main(){
    int i,j;
    ifstream fin("inputslr.txt");
    string num;
    vector<int> fs;
    vector<vector<int>> a;
    char start;
    bool flag = 0;
    cout<<"Grammar: "<<'\n';
    while(getline(fin,num)){
        if(flag == 0) start = num[0],flag = 1;
        cout<<num<<'\n';
        vector<char> temp;
        char s = num[0];
        for(i=3;i<num.size();i++){
            if(num[i] == '|'){
                mp[s].push_back(temp);
                temp.clear();
            }
            else temp.push_back(num[i]);
        }
        mp[s].push_back(temp);
    }
    map<char,set<char>> fmp;
    for(auto q : mp){
        ss.clear();
        dfs(q.first,q.first,q.first,mp);
        for(auto g : ss) fmp[q.first].insert(g);
    }

    cout<<'\n';
    cout<<"FIRST: "<<'\n';
    for(auto q : fmp){
        string ans = "";
        ans += q.first;
        ans += " = {";
        for(char r : q.second){
            ans += r;
            ans += ',';
        }
        ans.pop_back();
        ans+="}";
        cout<<ans<<'\n';
    }

    map<char,set<char>> gmp;
    gmp[start].insert('$');
    int count = 10;
    while(count--){
        for(auto q : mp){
            for(auto r : q.second){
                for(i=0;i<r.size()-1;i++){
                    if(r[i]>='A'&&r[i]<='Z'){
                        if(!(r[i+1]>='A'&&r[i+1]<='Z')) gmp[r[i]].insert(r[i+1]);
                        else {
                            char temp = r[i+1];
                            int j = i+1;
                            while(temp>='A'&&temp<='Z'){
                                if(*fmp[temp].begin()=='e'){
                                    for(auto g : fmp[temp]){
                                        if(g=='e') continue;
                                        gmp[r[i]].insert(g);
                                    }
                                    j++;
                                    if(j<r.size()){
                                        temp = r[j];
                                        if(!(temp>='A'&&temp<='Z')){
                                            gmp[r[i]].insert(temp);
                                            break;
                                        }
                                    }
                                    else{
                                        for(auto g : gmp[q.first]) gmp[r[i]].insert(g);
                                        break;
                                    }
                                }
                                else{
                                    for(auto g : fmp[temp]){
                                        gmp[r[i]].insert(g);
                                    }
                                    break;
                                }}}}}
                           
                if(r[r.size()-1]>='A'&&r[r.size()-1]<='Z'){
                    for(auto g : gmp[q.first]) gmp[r[i]].insert(g);
                }}}}
    cout<<'\n';
    cout<<"FOLLOW: "<<'\n';
    for(auto q : gmp){
        string ans = "";
        ans += q.first;
        ans += " = {";
        for(char r : q.second){
            ans += r;
            ans += ',';
        }
        ans.pop_back();
        ans+="}";
        cout<<ans<<'\n';
    }
    string temp = "";
    temp+='.';
    temp+=start;

    deque<char> emp;
    deque<char> st;
    st.push_back(start);
    dfs2('!','k',-1,{emp,st});

    cout<<"\nProductions: "<<'\n';
    int cc = 1;
    set<char> action,go;
    map<pair<char,deque<char>>,int> pos;
    for(auto q : mp){
        go.insert(q.first);
        for(auto r : q.second){
            cout<<"r"<<cc<<": ";
            string ans = "";
            ans += q.first;
            ans+="->";
            deque<char> temp;
            for(auto s : r) ans += s,temp.push_back(s);
            pos[{q.first,temp}] = cc;
            for(auto s : r){
                if(s>='A'&&s<='Z') go.insert(s);
                else action.insert(s);
            }
            cout<<ans<<'\n';
            cc++;
        }
    }
    
    cout<<"\nGraph: "<<'\n';
    for(auto mp2 : f){
        cout<<'\n';
        cout<<"I";
        cout<<mp2.first<<": \n";
        for(auto q : mp2.second){
            string ans = "";
            ans += q.first;
            ans += "->";
            for(auto r : q.second){
                for(auto t : r.first) ans+=t;
                ans+='.';
                for(auto t : r.second) ans+=t;
                ans+='|';
            }
            ans.pop_back();  
            for(auto tt : ans){
                if(tt == '!') cout<<start<<'\'';
                else cout<<tt;
            }
            cout<<'\n';
        }
    }
    cout<<'\n';
   
    cout<<"\nParsing Table:"<<'\n';
    cout<<"St.\t\tAction & Goto"<<'\n';
    int tot = f.size();
    cout<<"  \t";
    for(auto q : action) cout<<q<<'\t';
    for(auto q : go) cout<<q<<'\t';
    cout<<'\n';
    for(i=0;i<tot;i++){
        cout<<"I"<<i<<'\t';
        for(auto q : action){
            if(g.count(i)){
                int flag = 0;
                for(auto r : g[i]){
                    if(r.second == q){
                        flag = 1;
                        cout<<"S"<<r.first<<"\t";
                        break;
                    }
                }
                if(!flag) cout<<"-"<<'\t';
            }
            else{
                int flag = 0;
                for(auto r : f[i]){
                    if(r.first == '!'){
                        if(q == '$'){
                        cout<<"AC\t";
                        flag = 1;
                        }
                        else cout<<"-\t";
                    }  

                }
                if(!flag){
                    for(auto r : f[i]){
                        char ccc = r.first;
                        deque<char> chk = (*r.second.begin()).first;
                        int cou = 1;
                        for(auto r : gmp[ccc]){
                            if(q == r){
                                cout<<"r"<<pos[{ccc,chk}]<<"\t";
                            }
                            cou++;
                        }}}}

        for(auto q : go){
            if(g.count(i)){
                int flag = 0;
                for(auto r : g[i]){
                    if(r.second == q){
                        flag = 1;
                        cout<<r.first<<"\t";
                        break;
                    }
                }
                if(!flag) cout<<"-"<<'\t';
            }
            else{
                cout<<"-"<<'\t';
            }
        }
        cout<<'\n';
    }

    return 0;
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

9) Three Address Code

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void pm(char exp[]);
void plus(char exp[]);
void div(char exp[]);

int i, ch, j, l, addr = 100;
char ex[10], exp[10], exp1[10], exp2[10], id1[5], op[5], id2[5];

int main()
{
    while (1)
    {
        printf("\n1. Assignment\n2. Arithmetic\n3. Relational\n4. Exit\nEnter the choice: ");
        scanf("%d", &ch);

        switch (ch)
        {
        case 1:
            printf("\nEnter the expression with assignment operator: ");
            scanf("%s", exp);
            l = strlen(exp);
            exp2[0] = '\0';
            i = 0;
            while (exp[i] != '=')
            {
                i++;
            }
            strncat(exp2, exp, i);
            strrev(exp);
            exp1[0] = '\0';
            strncat(exp1, exp, l - (i + 1));
            strrev(exp1);
            printf("Three address code:\ntemp = %s\n%s = temp\n", exp1, exp2);
            break;

        case 2:
            printf("\nEnter the expression with arithmetic operator: ");
            scanf("%s", ex);
            l = strlen(ex);
            strcpy(exp, ex);
            exp1[0] = '\0';

            for (i = 0; i < l; i++)
            {
                if (exp[i] == '+' || exp[i] == '-')
                {
                    if (exp[i + 2] == '/' || exp[i + 2] == '*')
                    {
                        pm(exp);
                        break;
                    }
                    else
                    {
                        plus(exp);
                        break;
                    }
                }
                else if (exp[i] == '/' || exp[i] == '*')
                {
                    div(exp);
                    break;
                }
            }
            break;

        case 3:
            printf("Enter the expression with relational operator: ");
            scanf("%s %s %s", id1, op, id2);
            if (((strcmp(op, "<") == 0) || (strcmp(op, ">") == 0) || (strcmp(op, "<=") == 0) || (strcmp(op, ">=") == 0) || (strcmp(op, "==") == 0) || (strcmp(op, "!=") == 0)) == 0)
                printf("Expression is error");
            else
            {
                printf("\n%d\tif %s %s %s goto %d", addr, id1, op, id2, addr + 3);
                addr++;
                printf("\n%d\tT := 0", addr);
                addr++;
                printf("\n%d\tgoto %d", addr, addr + 2);
                addr++;
                printf("\n%d\tT := 1", addr);
            }
            break;

        case 4:
            exit(0);
        }
    }

    return 0;
}

void pm(char exp[])
{
    strrev(exp);
    j = l - i - 1;
    exp1[0] = '\0';
    strncat(exp1, exp, j);
    strrev(exp1);
    printf("Three address code:\ntemp = %s\ntemp1 = %c %c temp\n", exp1, exp[j + 1], exp[j]);
}

void div(char exp[])
{
    exp1[0] = '\0';
    strncat(exp1, exp, i + 2);
    printf("Three address code:\ntemp = %s\ntemp1 = temp %c %c\n", exp1, exp[i + 2], exp[i + 3]);
}

void plus(char exp[])
{
    exp1[0] = '\0';
    strncat(exp1, exp, i + 2);
    printf("Three address code:\ntemp = %s\ntemp1 = temp %c %c\n", exp1, exp[i + 2], exp[i + 3]);
}


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

10) Code Optimization Technique

#include <stdio.h>
#include <string.h>

struct Operation {
    char lhs;
    char rhs[20];
};

int main() {
    const int MAX_OPERATIONS = 10;
    struct Operation op[MAX_OPERATIONS], pr[MAX_OPERATIONS];
    int a, i, k, j, n, z = 0, m, q;
    char *p, *l;
    char temp, t;
    char *tem;

    printf("Enter the Number of Values: ");
    scanf("%d", &n);

    for (i = 0; i < n; i++) {
        printf("LHS Value: ");
        scanf(" %c", &op[i].lhs);
        printf("RHS Value: ");
        scanf(" %s", op[i].rhs);
    }

    printf("Intermediate Code:\n");
    for (i = 0; i < n; i++) {
        printf("%c=%s\n", op[i].lhs, op[i].rhs);
    }

    for (i = 0; i < n - 1; i++) {
        temp = op[i].lhs;
        for (j = 0; j < n; j++) {
            p = strchr(op[j].rhs, temp);
            if (p) {
                pr[z].lhs = op[i].lhs;
                strcpy(pr[z].rhs, op[i].rhs);
                z++;
            }
        }
    }

    pr[z].lhs = op[n - 1].lhs;
    strcpy(pr[z].rhs, op[n - 1].rhs);
    z++;

    printf("\nAfter Dead Code Elimination:\n");
    for (k = 0; k < z; k++) {
        printf("%c\t=%s\n", pr[k].lhs, pr[k].rhs);
    }

    for (m = 0; m < z; m++) {
        tem = pr[m].rhs;
        for (j = m + 1; j < z; j++) {
            p = strstr(tem, pr[j].rhs);
            if (p) {
                t = pr[j].lhs;
                pr[j].lhs = pr[m].lhs;
                for (i = 0; i < z; i++) {
                    l = strchr(pr[i].rhs, t);
                    if (l) {
                        a = l - pr[i].rhs;
                        printf("pos: %d\n", a);
                        pr[i].rhs[a] = pr[m].lhs;
                    }
                }
            }
        }
    }

    printf("Eliminate Common Expression:\n");
    for (i = 0; i < z; i++) {
        printf("%c\t=%s\n", pr[i].lhs, pr[i].rhs);
    }

    for (i = 0; i < z; i++) {
        for (j = i + 1; j < z; j++) {
            q = strcmp(pr[i].rhs, pr[j].rhs);
            if ((pr[i].lhs == pr[j].lhs) && !q) {
                pr[i].lhs = '\0';
            }
        }
    }

    printf("Optimized Code:\n");
    for (i = 0; i < z; i++) {
        if (pr[i].lhs != '\0') {
            printf("%c=%s\n", pr[i].lhs, pr[i].rhs);
        }
    }

    return 0;
}


